<mxfile host="app.diagrams.net" modified="2021-05-19T05:22:17.799Z" agent="5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36" etag="HPl2QrtS3dXI-hxc9NL_" version="14.6.13" type="github" pages="2">
  <diagram id="jmOzARPnvOpFAgRpLUe-" name="Lesson 1 - 4">
    <mxGraphModel dx="946" dy="614" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="Z19wWoIML4QPCTQ_kCz8-1" value="1) React framework for production. Full stack framework for ReactJS&lt;br&gt;2) clear rules and guidelines on how to structure our code so that they ready for production." style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="1530" y="30" width="840" height="60" as="geometry" />
        </mxCell>
        <mxCell id="Z19wWoIML4QPCTQ_kCz8-2" value="Key Feature 1 - Built in server-side rendering&lt;br&gt;1) Normal client side React apps only render a simple HTML element from the server on Loading.&amp;nbsp;&lt;br&gt;2) After loading the react app is then installed on the client browser from where the user can navigate and look at rendered data.&lt;br&gt;3) This means that for the first time the user might see a loading state and also this is not great for SEO. because the SEO crawlers can only see HTML content.&amp;nbsp;&lt;br&gt;4) There are ways around this by implementing specific packages/ libraries through REACT.&amp;nbsp;&lt;br&gt;5. However this is inefficient and not advisable.&amp;nbsp;&lt;br&gt;6. This is where NEXTJS can be useful. It helps in pre rendering all server side data so that the users dont have to see the loading state and also the web crawlers can pick up information straight away.&lt;br&gt;7)After the first load, everything else is handled by the react side code. To help in fast user experience" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="1530" y="130" width="840" height="260" as="geometry" />
        </mxCell>
        <mxCell id="Zn38Q3lzgTLnzNLuBiVa-1" value="Key Feature 2 - Simplified Routing.&lt;br&gt;1) In react js routing is a complicated topic.&amp;nbsp;&lt;br&gt;2) User has to download a package and then write code to achieve things like routing, dynamic routing and nested routing.&amp;nbsp;&lt;br&gt;3) In Next JS this is not necessary. we can create a folder structure alone with specified routing and that alone will help to perform routing without writing extra code." style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="1530" y="410" width="840" height="260" as="geometry" />
        </mxCell>
        <mxCell id="Zn38Q3lzgTLnzNLuBiVa-2" value="Key Feature 3 - Fullstack framework&lt;br&gt;1) React is a predominantly front end client side development framework.&lt;br&gt;2) While using React projects we have to make sure that the back end is Node and the database is served through the NODE js rest API.&lt;br&gt;3) However NEXT solves this problem for us. While using NEXT we can blend in server side NODE js code into the front end and this helps us to work through one project, integrating both the front end and the back end" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="1530" y="720" width="840" height="260" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
  <diagram id="kwprIsWyF4qIicG6Lafi" name="Lesson 3- Key Feature 2(Simplified Routing)">
    <mxGraphModel dx="946" dy="5295" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" math="0" shadow="0">
      <root>
        <mxCell id="G_h5FC7eXMKvEeGqqYIe-0" />
        <mxCell id="G_h5FC7eXMKvEeGqqYIe-1" parent="G_h5FC7eXMKvEeGqqYIe-0" />
        <mxCell id="qWRvA82q6f-NavhIfvpX-0" value="Server Side Rendering&amp;nbsp;&lt;br&gt;1) When we use Next js, the component is pre-rendered with data and then brought to the client side browser. Useful for SEO and user experience.&amp;nbsp;&lt;br&gt;2) But what happens if the data that we have is on DB or an external API, where we have to fetch data.&lt;br&gt;3) Typically you will use useEffect and useState to fetch the data. But useEffect runs after the first component cycle. This means that for the first time an empty page will be loaded. This will harm user experience and also the SEO.&amp;nbsp;&lt;br&gt;4) Next JS solves this problem in 2 ways , static site generation or server side rendering. SSG solves this by&amp;nbsp; providing a function called getStaticProps.&amp;nbsp;&lt;br&gt;5) You write this function below the main react component in the page that you want to use it in.&amp;nbsp;&lt;br&gt;6) When the page is loaded for the first time in the client side, Next JS runs through the code and if it sees this function, it will stop execution and not render anything. We can ensure this with the async keyword.&amp;nbsp;&lt;br&gt;7) In this function then you can write the fetch code to get the required data from a DB or an external API and return an object to the component to the page&amp;nbsp;&lt;br&gt;8) The component on the page will accept this as props and then pass the values to the overall react render cycle.&amp;nbsp;&lt;br&gt;9) However SSG is deployed during build process. If after the deployment process if more data is added to the backend then this could be an issue, as data will not be in synch.&lt;br&gt;10) Next js solves this by providing a second parameter on the getStaticProps function called revalidate. Revalidates takes a number and thats the number of seconds.&amp;nbsp;&lt;br&gt;11) When Next js sees this number it understands that even after deployment, every 10 seconds it needs to refresh this page with the correct data. This means that the data with the DB will keep getting refreshed every 10 seconds without fail. This number that we provide is based on our app and how frequently we want the data to refresh.&amp;nbsp;&lt;br&gt;12) An alternative approach to SSG is ServerSideRendering. In this, instead of building the page during build and deployment, NEXTJS will dynamically render the data during every request cycle. This should be used if the data in the back end is getting frequently updated, else SSG is a better option.&amp;nbsp;&lt;br&gt;13) Only replace getStaticProps with getServerSideProps. Rest of the functionality remains the same.&amp;nbsp;&lt;br&gt;14) If we are using getStaticProps for dynamic rendering of pages then we will have an issue with dynamically rendering the URL params. We can still get the values through context however rendering will fail during run time.&amp;nbsp;&lt;br&gt;15) So if we are using SSG and doing dynamic rendering then we need a second export function called getStaticPaths&lt;br&gt;16) This function also returns an object and now we have 2 ways to pass the dynamic object for rendering. We can either tell this function that we are passing all the unique ids, which we can then fetch from the DB put it an array and provide. or we can say that we are passing some of the unique ids.&amp;nbsp;&lt;br&gt;17) This is decided by the parameter fallback. if fallback is set to false it means we are passing all the unique ids and if a request is made for a resource not available, then a 404 error page will be displayed. If the fallback is set to true. It means during the build process SSG will keep a few dummy pages in store for values that are not available.&lt;br&gt;18) Keep in mind that all&amp;nbsp;" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="G_h5FC7eXMKvEeGqqYIe-1">
          <mxGeometry x="100" y="-3080" width="840" height="780" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
